clear all; close all; clc;

%% FMCW Radar Signal Processing Pipeline & Range-Doppler Generation
%  Description: This script processes raw ADC data from an FMCW radar, applies
%  2D-FFT, MTI filtering, and advanced noise suppression to generate a clean
%  Range-Doppler video (GIF).
%
%  [IMPORTANT REQUIREMENT]: This script requires the 'readDCA1000.m' function 
%  to parse the binary file. Ensure you have the raw .bin file generated by 
%  your FPGA/DCA1000 capture card.

%% ========================================================================
%  SECTION 1: RADAR CONFIGURATION & PARAMETERS
%  [CRITICAL NOTE]: The parameters below are specific to the hardware setup 
%  used in this project (e.g., TI mmWave Sensor + DCA1000EVM).
%  !!! YOU MUST UPDATE THESE VALUES TO MATCH YOUR OWN DATASET !!!
% ========================================================================

% --- Radar Hardware Setup ---
numRX = 4;                            % Number of Receiver (RX) antennas
numTX = 2;                            % Number of Transmitter (TX) antennas (TX0, TX1)
c = 3e8;                              % Speed of light (m/s)

% --- mmWave Studio / Waveform Configuration ---
f = 60e9;                             % Start Frequency (e.g., 60 GHz or 77 GHz)
S = 29.982 * 1e12;                    % Chirp Slope (Hz/s)
chirpNum = 128;                       % Number of chirps per frame
frameNum = 400;                       % Total number of frames recorded
N = 256;                              % Number of ADC samples per chirp
fs = 5000 * 1e3;                      % Sampling Rate (5 MHz)

% --- Timing Parameters ---
idleTime = 4.00 * 1e-6;               % Idle time between chirps
adcStartTime = 1.00 * 1e-6;           % Time before ADC sampling starts
rampEndTime = 85.00 * 1e-6;           % End time of the frequency ramp
Tc = rampEndTime + idleTime;          % Total Chirp Duration

% --- Processing & Visualization Settings (My Custom Tuning) ---
NFFT_range = 1024;                    % Range FFT size (Zero-padding for higher resolution)
NFFT_doppler = chirpNum;              % Doppler FFT size (128)
frameStart = 100;                     % Start processing from this frame
frameEnd = 250;                       % End processing at this frame
gifFileName = 'Final_Clean_Radar_Output.gif'; % Output filename
delayTime = 0.1;                      % GIF frame delay (0.1s is smooth)

%% ========================================================================
%  SECTION 2: THEORETICAL CALCULATIONS
% ========================================================================
lambda = c/f;                         % Wavelength
Ts = 1/fs;                            % Sampling period
B = S * (rampEndTime - adcStartTime); % Valid Bandwidth (ADC active time only)
d_res = c / (2 * B);                  % Range Resolution
d_max = (fs * c)/(2*S);               % Maximum Range

% --- Velocity Calculations ---
singleChirpTime = rampEndTime + idleTime; 
Tc_eff = numTX * singleChirpTime;     % Effective Chirp Time (TDM MIMO: 2 * Tc)
Tf = chirpNum * Tc_eff;               % Total Frame Duration
v_max = lambda/(4*Tc_eff);            % Max Measurable Velocity
v_res = lambda/(2*Tf);                % Velocity Resolution

% --- Console Output for Verification ---
fprintf('--- System Parameters ---\n');
fprintf('Bandwidth (B): %.2f MHz\n', B / 1e6);
fprintf('Effective Chirp Time (Tc_eff): %.2f us\n', Tc_eff * 1e6);
fprintf('Range Resolution: %.2f m\n', d_res);
fprintf('Max Range: %.2f m\n', d_max);
fprintf('Velocity Resolution: %.2f m/s\n', v_res);
fprintf('Max Velocity: %.2f m/s\n', v_max);
fprintf('Total Recording Time: %.2f seconds\n', frameNum * Tf);
fprintf('--------------------------------------------------\n');

%% ========================================================================
%  SECTION 3: DATA INGESTION & 5D MATRIX FORMATION
% ========================================================================
fileName = 'data42.bin';              % Raw binary file from DCA1000
numADCBits = 16; 

% [MY NOTE]: Using the standard TI script to read binary data.
% Ensure 'readDCA1000.m' is in your MATLAB path.
adcData = readDCA1000(fileName, N, numADCBits, numRX, 0);

% --- Reshaping & Permuting Data ---
totalChirps = size(adcData, 2) / N; 
adcData_reshaped = reshape(adcData, numRX, N, totalChirps);
adcData_manual = permute(adcData_reshaped, [1 3 2]); % Dimensions: [RX, Chirp, Sample]

% --- Integrity Check ---
expectedTotal = frameNum * numTX * chirpNum;
if abs(totalChirps - expectedTotal) > numTX*chirpNum 
    warning('Data mismatch detected! Adjusting frameNum to match actual data size.');
    frameNum = floor(totalChirps / (chirpNum * numTX)); 
    if frameEnd > frameNum 
        frameEnd = frameNum; 
    end
end

% --- Creating the 5D Cube [RX, TX, Frame, Chirp, Sample] ---
% This structure allows easy access to any dimension of the radar data.
adcData_final = zeros(numRX, numTX, frameNum, chirpNum, N);
chirpCounter = 1;

for frame = 1:frameNum
    for chirp = 1:chirpNum
        for tx = 1:numTX % Processing TDM (Time Division Multiplexing) sequence
            adcData_final(:, tx, frame, chirp, :) = adcData_manual(:, chirpCounter, :);
            chirpCounter = chirpCounter + 1;
        end
    end
end
disp('Data successfully loaded and reshaped into 5D matrix.');

% --- Axis Preparation ---
rangeBins = (0:NFFT_range-1) * (d_max / NFFT_range);
velocityBins = linspace(-v_max, v_max, NFFT_doppler);

% --- PRE-PROCESSING: Window Functions ---
% [MY NOTE]: Hamming window reduces spectral leakage (sidelobes) in FFT.
window_range = hamming(N).';
window_doppler = hamming(chirpNum);

%% ========================================================================
%  SECTION 4: SIGNAL PROCESSING CHAIN & GIF GENERATION
% ========================================================================

% Create invisible figure for background processing
h_fig_gif = figure('Position', [100 100 800 600], 'Name', 'Final RDM Processing', 'Visible', 'off');

caxis_limits = [-40, 0]; % Dynamic Range (dB) for visualization
fprintf('Starting GIF generation for frames %d to %d...\n', frameStart, frameEnd);

% [MY NOTE]: Tuning the Noise Floor Offset. 
% 10dB provided the best balance between clutter removal and target preservation.
NOISE_FLOOR_OFFSET_DB = 10; 

for frameIndex = frameStart:frameEnd
    
    % Combine TX antennas (Non-coherent integration for SNR boost)
    frameData = squeeze(sum(adcData_final(:, :, frameIndex, :, :), 2));
    
    % --- STEP 1: Range FFT (with Windowing) ---
    frameData_windowed_range = frameData.* reshape(window_range, [1 1 N]);
    rangeFFT = fft(frameData_windowed_range, NFFT_range, 3);
    
    % --- STEP 2: MTI Filter (Static Clutter Suppression) ---
    % [MY NOTE]: Subtracting the mean removes static objects (0 Doppler) like walls.
    rangeFFT_mti = rangeFFT - mean(rangeFFT, 2); 
    
    % --- STEP 3: Doppler FFT (with Windowing) ---
    rangeFFT_windowed_doppler = rangeFFT_mti .* reshape(window_doppler, [1 chirpNum 1]);
    dopplerFFT = fft(rangeFFT_windowed_doppler, NFFT_doppler, 2);
    dopplerFFT = fftshift(dopplerFFT, 2); % Shift Zero-Doppler to center
    
    % --- Generate Range-Doppler Map (Logarithmic Scale) ---
    rangeDopplerMap = squeeze(mean(abs(dopplerFFT), 1));
    rangeDopplerMap_db = 20*log10(rangeDopplerMap);
    
    % --- STEP 4: MEDIAN FILTER ---
    % [MY NOTE]: Removes 'salt-and-pepper' noise spikes without blurring edges.
    rangeDopplerMap_db_med = medfilt2(rangeDopplerMap_db, [3 3]); 
    
    % --- STEP 5: ADAPTIVE NOISE FLOOR THRESHOLDING ---
    % [ALGORITHM]: 
    % 1. Sort pixel intensities.
    % 2. Estimate noise floor using the lower 50% of values.
    % 3. Apply threshold (Noise Floor + Offset).
    
    sorted_pixels = sort(rangeDopplerMap_db_med(:));
    noise_pixels = sorted_pixels(1 : floor(length(sorted_pixels) / 2));
    avg_noise_floor_db = mean(noise_pixels);
    
    threshold_db = avg_noise_floor_db + NOISE_FLOOR_OFFSET_DB;
    
    % Mask signals below threshold
    rangeDopplerMap_db_med(rangeDopplerMap_db_med < threshold_db) = -inf;
    
    % --- STEP 6: NORMALIZATION ---
    % Normalize so the strongest target is at 0 dB
    rangeDopplerMap_db_final = rangeDopplerMap_db_med - max(rangeDopplerMap_db_med(:));

    % --- Visualization ---
    clf(h_fig_gif); 
    imagesc(velocityBins, rangeBins, rangeDopplerMap_db_final.');
    xlabel('Velocity (m/s)');
    ylabel('Range (m)');
    title(sprintf('Processed Range-Doppler Map - Frame: %d', frameIndex));
    axis xy;
    colorbar;
    caxis(caxis_limits); % Fix color scale for consistency
    
    drawnow; 
    
    % --- GIF Capture ---
    frame = getframe(h_fig_gif);
    im = frame2im(frame);
    [imind, cm] = rgb2ind(im, 256);
    
    if frameIndex == frameStart 
        imwrite(imind, cm, gifFileName, 'gif', 'Loopcount', inf, 'DelayTime', delayTime);
    else 
        imwrite(imind, cm, gifFileName, 'gif', 'WriteMode', 'append', 'DelayTime', delayTime);
    end
    
    fprintf('Processed Frame: %d\n', frameIndex);
end

fprintf('Success! Cleaned GIF saved as: %s\n', gifFileName);
close(h_fig_gif);